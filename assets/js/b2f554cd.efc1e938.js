"use strict";(globalThis.webpackChunkdocs_v_2=globalThis.webpackChunkdocs_v_2||[]).push([[894],{6042:t=>{t.exports=JSON.parse('{"blogPosts":[{"id":"ogen-intro","metadata":{"permalink":"/blog/ogen-intro","source":"@site/blog/2022-11-30-ogen.md","title":"ogen: OpenAPI v3 code generator for Go","description":"The ogen project generates code from an OpenAPI specification, freeing you from writing hundreds (or even thousands) of lines of boring boilerplate code on Go.","date":"2022-11-30T00:00:00.000Z","formattedDate":"November 30, 2022","tags":[],"readingTime":9.785,"hasTruncateMarker":false,"authors":[{"name":"tdakkota","title":"ogen maintainer","url":"https://github.com/tdakkota","imageURL":"https://github.com/tdakkota.png","key":"tdakkota"},{"name":"Aleksandr Razumov","title":"ogen maintainer","url":"https://github.com/ernado","imageURL":"https://github.com/ernado.png","key":"ernado"}],"frontMatter":{"slug":"ogen-intro","title":"ogen: OpenAPI v3 code generator for Go","authors":["tdakkota","ernado"]}},"content":"The [ogen](https://github.com/ogen-go/ogen) project generates code from an OpenAPI specification, freeing you from writing hundreds (or even thousands) of lines of boring boilerplate code on Go.\\n\\nIt generates client and server implementations for Go. Developers just need to implement the request handler. No `interface{}` and no `reflect`, only strong types and codegen.\\n\\nIn this article I will tell what makes ogen different from other code generators and why you should try it.\\n\\n\\n## Strong types\\nogen generates strongly-typed client and server, similar to gRPC. Also, ogen adds endpoint description for each generated method.\\n\\nFor the server, the `Handler` interface is generated that needs to be implemented:\\n```go\\n// Handler handles operations described by OpenAPI v3 specification.\\ntype Handler interface {\\n\\t// AddPet implements addPet operation.\\n\\t//\\n\\t// Creates a new pet in the store. Duplicates are allowed.\\n\\t//\\n\\t// POST /pets\\n\\tAddPet(ctx context.Context, req NewPet) (AddPetRes, error)\\n\\t// DeletePet implements deletePet operation.\\n\\t//\\n\\t// Deletes a single pet based on the ID supplied.\\n\\t//\\n\\t// DELETE /pets/{id}\\n\\tDeletePet(ctx context.Context, params DeletePetParams) (DeletePetRes, error)\\n\\t// FindPetByID implements find pet by id operation.\\n\\t//\\n\\t// Returns a user based on a single ID, if the user does not have access to the pet.\\n\\t//\\n\\t// GET /pets/{id}\\n\\tFindPetByID(ctx context.Context, params FindPetByIDParams) (FindPetByIDRes, error)\\n\\t// FindPets implements findPets operation.\\n\\t//\\n\\t// Returns all pets from the system that the user has access to\\n\\t//\\n\\t// GET /pets\\n\\tFindPets(ctx context.Context, params FindPetsParams) (FindPetsRes, error)\\n\\t// PatchPet implements patchPet operation.\\n\\t//\\n\\t// Patch a pet.\\n\\t//\\n\\t// PATCH /pets/{id}\\n\\tPatchPet(ctx context.Context, req UpdatePet, params PatchPetParams) (PatchPetRes, error)\\n}\\n```\\n\\nClient code is quite similar:\\n```go\\nfunc (c *Client) AddPet(ctx context.Context, request NewPet) (res AddPetRes, err error) {}\\n\\n// PatchPet invokes patchPet operation.\\n//\\n// Patch a pet.\\n//\\n// PATCH /pets/{id}\\nfunc (c *Client) PatchPet(ctx context.Context, request UpdatePet, params PatchPetParams) (res PatchPetRes, err error) {}\\n```\\n\\n## Validation\\n\\nogen supports `maxLength`, `minLength`, `pattern` (regex), `minimum`, `maximum` and other validators for strings, arrays, objects and numbers.\\n\\n```yaml\\nUpdatePet:\\n  type: object\\n  properties:\\n    name:\\n      type: string\\n      maxLength: 25\\n      minLength: 3\\n      pattern: \'^[a-zA-Z0-9]+$\'\\n    tag:\\n      maxLength: 10\\n      minLength: 1\\n      pattern: \'^[a-zA-Z0-9]+$\'\\n      nullable: true\\n      type: string\\n```\\n\\n### Unknown and required fields\\n\\nFurthermore, it is checked in the effective way that required fields are set, and unknown (if not allowed) are not passed:\\n```go\\n// Validate required fields.\\nvar failures []validate.FieldError\\nfor i, mask := range [1]uint8{\\n\\t0b00000001,\\n} {\\n\\tif result := (requiredBitSet[i] & mask) ^ mask; result != 0 {\\n\\t\\t// Mask only required fields and check equality to mask using XOR.\\n\\t\\t//\\n\\t\\t// If XOR result is not zero, result is not equal to expected, so some fields are missed.\\n\\t\\t// Bits of fields which would be set are actually bits of missed fields.\\n\\t\\tmissed := bits.OnesCount8(result)\\n\\t\\tfor bitN := 0; bitN < missed; bitN++ {\\n\\t\\t\\tbitIdx := bits.TrailingZeros8(result)\\n\\t\\t\\tfieldIdx := i*8 + bitIdx\\n\\t\\t\\tvar name string\\n\\t\\t\\tif fieldIdx < len(jsonFieldsNameOfNewPet) {\\n\\t\\t\\t\\tname = jsonFieldsNameOfNewPet[fieldIdx]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tname = strconv.Itoa(fieldIdx)\\n\\t\\t\\t}\\n\\t\\t\\tfailures = append(failures, validate.FieldError{\\n\\t\\t\\t\\tName:  name,\\n\\t\\t\\t\\tError: validate.ErrFieldRequired,\\n\\t\\t\\t})\\n\\t\\t\\t// Reset bit.\\n\\t\\t\\tresult &^= 1 << bitIdx\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n### Enum\\n\\nThe `enum` validator is fully supported. The enum values are generated as constants, and validation code is generated as well for the client and server:\\n```go\\n// Ref: #/components/schemas/Kind\\ntype Kind string\\n\\nconst (\\n   KindCat   Kind = \\"Cat\\"\\n   KindDog   Kind = \\"Dog\\"\\n   KindFish  Kind = \\"Fish\\"\\n   KindBird  Kind = \\"Bird\\"\\n   KindOther Kind = \\"Other\\"\\n)\\n\\nfunc (s Kind) Validate() error {\\n\\tswitch s {\\n\\tcase \\"Cat\\":\\n\\t\\treturn nil\\n\\tcase \\"Dog\\":\\n\\t\\treturn nil\\n\\tcase \\"Fish\\":\\n\\t\\treturn nil\\n\\tcase \\"Bird\\":\\n\\t\\treturn nil\\n\\tcase \\"Other\\":\\n\\t\\treturn nil\\n\\tdefault:\\n\\t\\treturn errors.Errorf(\\"invalid value: %v\\", s)\\n\\t}\\n}\\n\\n// Decode decodes Kind from json.\\nfunc (s *Kind) Decode(d *jx.Decoder) error {\\n\\tif s == nil {\\n\\t\\treturn errors.New(\\"invalid: unable to decode Kind to nil\\")\\n\\t}\\n\\tv, err := d.StrBytes()\\n\\tif err != nil {\\n\\t\\treturn err\\n\\t}\\n\\t// Try to use constant string.\\n\\tswitch Kind(v) {\\n\\tcase KindCat:\\n\\t\\t*s = KindCat\\n\\tcase KindDog:\\n\\t\\t*s = KindDog\\n\\tcase KindFish:\\n\\t\\t*s = KindFish\\n\\tcase KindBird:\\n\\t\\t*s = KindBird\\n\\tcase KindOther:\\n\\t\\t*s = KindOther\\n\\tdefault:\\n\\t\\t*s = Kind(v)\\n\\t}\\n\\n\\treturn nil\\n}\\n\\n\\n```\\n\\nUnlike `ogen`, `deepmap/oapi-codegen` does not check `enum` values. It only generates the named type and constants.\\n\\n## Without pointers\\n\\nIf it is possible.\\n\\nIn most cases, to represent optional (or nullable) fields in Go, pointers are usually used:\\n```go\\ntype Pet struct {\\n    // Name of the pet\\n    Name string `json:\\"name\\"`\\n\\n    // Type of the pet\\n    Tag *string `json:\\"tag,omitempty\\"`\\n}\\n```\\n\\nThis is a common, but hacky way:\\n* It is easy to get null pointer exception, hello *The Billion Dollar Mistake*\\n* It increases the GC pressure, especially if there are many objects or they are nested (e.g. `[]Pet`)\\n* It is impossible to express nullable optional when three states can be passed: empty, `null` and filled value. It is especially useful for `PATCH` operations.\\n\\nogen solves this problem by generating generic types:\\n```go\\n// Ref: #/components/schemas/NewPet\\ntype NewPet struct {\\n   Name string    `json:\\"name\\"`\\n   Tag  OptString `json:\\"tag\\"`\\n}\\n\\n// OptString is optional string.\\ntype OptString struct {\\n   Value string\\n   Set   bool\\n}\\n```\\n\\nIt seems that [deepmap/oapi-codegen](https://github.com/deepmap/oapi-codegen) cannot handle optional nullable properly:\\n```go\\n// UpdatePet defines model for UpdatePet.\\ntype UpdatePet struct {\\n   Name *string `json:\\"name,omitempty\\"`\\n   Tag  *string `json:\\"tag\\"`\\n}\\n```\\nWhereas ogen generates a special `OptNilString` type:\\n```go\\n// Ref: #/components/schemas/UpdatePet\\ntype UpdatePet struct {\\n   Name OptString    `json:\\"name\\"`\\n   Tag  OptNilString `json:\\"tag\\"`\\n}\\n\\n// OptNilString is optional nullable string.\\ntype OptNilString struct {\\n   Value string\\n   Set   bool\\n   Null  bool\\n}\\n```\\nUsing `OptNilString` you can express any state: the absence of the value, `null` value, an empty string, and just a string.\\n\\n### Arrays\\nTo represent arrays, a special type may not be generated, changing the semantics of the `nil` value of the slice depending on the schema. For example, if the field is `optional`, then `nil` will mean the absence of the value. If `nullable`, then `null`. For optional nullable fields, you will have to generate a wrapper.\\n\\n\\n## JSON implementation without reflection\\n\\nogen does not use the standard `encoding/json` with its limitations in speed and capabilities. Instead, it generates a static code for encoding and decoding JSON.\\n\\n```go\\n// Encode encodes string as json.\\nfunc (o OptNilString) Encode(e *jx.Encoder) {\\n   if !o.Set {\\n      return\\n   }\\n   if o.Null {\\n      e.Null()\\n      return\\n   }\\n   e.Str(string(o.Value))\\n}\\n```\\n\\nIt lets you make working with json more efficient and flexible. For example, decoding a field in several passes to support `oneOf` with a discriminator (first the value of the discriminator field is parsed, and then the value as a whole) and without it (first all fields are traversed and the type is selected by unique fields).\\n\\nInstead of `encoding/json`, ogen uses [go-faster/jx](https://github.com/go-faster/jx), a heavily modified and optimized fork of `jsoniter` (can parse almost a gigabyte of json logs in a second per core).\\n\\n\\n## Custom router\\n`ogen` uses its own, efficient statically generated router based on radix tree:\\n```go\\n// ...\\n// Static code generated router with unwrapped path search.\\nswitch {\\ndefault:\\n\\tif len(elem) == 0 {\\n\\t\\tbreak\\n\\t}\\n\\tswitch elem[0] {\\n\\tcase \'/\': // Prefix: \\"/pets\\"\\n\\t\\tif l := len(\\"/pets\\"); len(elem) >= l && elem[0:l] == \\"/pets\\" {\\n\\t\\t\\telem = elem[l:]\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(elem) == 0 {\\n\\t\\t\\tswitch r.Method {\\n\\t\\t\\tcase \\"GET\\":\\n\\t\\t\\t\\ts.handleFindPetsRequest([0]string{}, w, r)\\n\\t\\t\\tcase \\"POST\\":\\n\\t\\t\\t\\ts.handleAddPetRequest([0]string{}, w, r)\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\ts.notAllowed(w, r, \\"GET,POST\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tswitch elem[0] {\\n\\t\\tcase \'/\': // Prefix: \\"/\\"\\n\\t\\t\\tif l := len(\\"/\\"); len(elem) >= l && elem[0:l] == \\"/\\" {\\n\\t\\t\\t\\telem = elem[l:]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n// ...\\n```\\n\\nStatic router allows the compiler to make many optimizations: remove unnecessary bounds checks, optimize string comparison,\\nuse [optimal `case` search algorithm](https://go-review.googlesource.com/c/go/+/357330) instead of [binary search](https://github.com/go-chi/chi/blob/e5529d9db4d3d45bab5aa1e691e36d45ee5b082f/tree.go#L799-L808).\\n\\nIt makes ogen routing much faster than `chi` and `echo` ([benchmark](https://gist.github.com/tdakkota/9ef35ce009425a23662108e537b970e2)):\\n```\\nname                        time/op\\nRouter/GithubStatic/ogen-4  18.7ns \xb1 3%\\nRouter/GithubStatic/chi-4    146ns \xb1 2%\\nRouter/GithubStatic/echo-4  73.7ns \xb1 9%\\nRouter/GithubParam/ogen-4   34.0ns \xb1 3%\\nRouter/GithubParam/chi-4     251ns \xb1 3%\\nRouter/GithubParam/echo-4    118ns \xb1 2%\\nRouter/GithubAll/ogen-4     56.6\xb5s \xb1 3%\\nRouter/GithubAll/chi-4       323\xb5s \xb1 3%\\nRouter/GithubAll/echo-4      173\xb5s \xb1 4%\\n\\nname                        alloc/op\\nRouter/GithubStatic/ogen-4   0.00B\\nRouter/GithubStatic/chi-4    0.00B\\nRouter/GithubStatic/echo-4   0.00B\\nRouter/GithubParam/ogen-4    0.00B\\nRouter/GithubParam/chi-4     0.00B\\nRouter/GithubParam/echo-4    0.00B\\nRouter/GithubAll/ogen-4      0.00B\\nRouter/GithubAll/chi-4       0.00B\\nRouter/GithubAll/echo-4      0.00B\\n```\\n\\n\\n## OneOf\\nLet\'s imagine that we have a schema like this:\\n```yaml\\nDog:\\n  type: object\\n  required:\\n    - kind\\n  properties:\\n    kind:\\n      $ref: \'#/components/schemas/Kind\'\\n    bark:\\n      type: string\\nCat:\\n  type: object\\n  required:\\n    - kind\\n  properties:\\n    kind:\\n      $ref: \'#/components/schemas/Kind\'\\n    meow:\\n      type: string\\nSomePet:\\n  type: object\\n  discriminator:\\n    propertyName: kind\\n  oneOf:\\n    - $ref: \'#/components/schemas/Dog\'\\n    - $ref: \'#/components/schemas/Cat\'\\n```\\n\\nogen will generate code like this:\\n```go\\n// Ref: #/components/schemas/Cat\\ntype Cat struct {\\n\\tKind Kind      `json:\\"kind\\"`\\n\\tMeow OptString `json:\\"meow\\"`\\n}\\n\\n// Ref: #/components/schemas/Dog\\ntype Dog struct {\\n\\tKind Kind      `json:\\"kind\\"`\\n\\tBark OptString `json:\\"bark\\"`\\n}\\n\\n// Ref: #/components/schemas/SomePet\\n// SomePet represents sum type.\\ntype SomePet struct {\\n\\tType SomePetType // switch on this field\\n\\tDog  Dog\\n\\tCat  Cat\\n}\\n```\\n\\nAs you can see, the `oneOf` case is chosen during the decoding process.\\n```go\\n// func (s *SomePet) Decode(d *jx.Decoder) error\\nif err := d.Capture(func(d *jx.Decoder) error {\\n\\treturn d.ObjBytes(func(d *jx.Decoder, key []byte) error {\\n\\t\\tif found {\\n\\t\\t\\treturn d.Skip()\\n\\t\\t}\\n\\t\\tswitch string(key) {\\n\\t\\tcase \\"kind\\":\\n\\t\\t\\ttyp, err := d.Str()\\n\\t\\t\\tif err != nil {\\n\\t\\t\\t\\treturn err\\n\\t\\t\\t}\\n\\t\\t\\tswitch typ {\\n\\t\\t\\tcase \\"Cat\\":\\n\\t\\t\\t\\ts.Type = CatSomePet\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\tcase \\"Dog\\":\\n\\t\\t\\t\\ts.Type = DogSomePet\\n\\t\\t\\t\\tfound = true\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn errors.Errorf(\\"unknown type %s\\", typ)\\n\\t\\t\\t}\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\t\\treturn d.Skip()\\n\\t})\\n}); err != nil {\\n\\treturn errors.Wrap(err, \\"capture\\")\\n}\\nif !found {\\n\\treturn errors.New(\\"unable to detect sum type variant\\")\\n}\\nswitch s.Type {\\ncase DogSomePet:\\n\\tif err := s.Dog.Decode(d); err != nil {\\n\\t\\treturn err\\n\\t}\\ncase CatSomePet:\\n\\tif err := s.Cat.Decode(d); err != nil {\\n\\t\\treturn err\\n\\t}\\ndefault:\\n\\treturn errors.Errorf(\\"inferred invalid type: %s\\", s.Type)\\n}\\n```\\n\\nWhereas `deepmap/oapi-codegen` requires an additional manual call (Also, notice that at the moment of posting this article, the generated code is broken):\\n```go\\n// SomePet defines model for SomePet.\\ntype SomePet struct {\\n\\tunion json.RawMessage\\n}\\n\\nfunc (t SomePet) Discriminator() (string, error) {\\n\\tvar discriminator struct {\\n\\t\\tDiscriminator string `json:\\"kind\\"`\\n\\t}\\n\\terr := json.Unmarshal(t.union, &discriminator)\\n\\treturn discriminator.Discriminator, err\\n}\\n\\n// AsCat returns the union data inside the SomePet as a Cat\\nfunc (t SomePet) AsCat() (Cat, error) {\\n\\tvar body Cat\\n\\terr := json.Unmarshal(t.union, &body)\\n\\treturn body, err\\n}\\n\\n```\\nIt seems that the developer should write the entire `switch`-by-discriminator logic by himself.\\n\\n### Without `discriminator`\\nFurther, `ogen` can work **without the explicit discriminator field** at all, choosing the type by unique fields:\\n\\n```go\\nvar found bool\\nif err := d.Capture(func(d *jx.Decoder) error {\\n\\treturn d.ObjBytes(func(d *jx.Decoder, key []byte) error {\\n\\t\\tswitch string(key) {\\n\\t\\tcase \\"bark\\":\\n\\t\\t\\tmatch := DogSomePet\\n\\t\\t\\tif found && s.Type != match {\\n\\t\\t\\t\\ts.Type = \\"\\"\\n\\t\\t\\t\\treturn errors.Errorf(\\"multiple oneOf matches: (%v, %v)\\", s.Type, match)\\n\\t\\t\\t}\\n\\t\\t\\tfound = true\\n\\t\\t\\ts.Type = match\\n\\t\\tcase \\"meow\\":\\n\\t\\t\\tmatch := CatSomePet\\n\\t\\t\\tif found && s.Type != match {\\n\\t\\t\\t\\ts.Type = \\"\\"\\n\\t\\t\\t\\treturn errors.Errorf(\\"multiple oneOf matches: (%v, %v)\\", s.Type, match)\\n\\t\\t\\t}\\n\\t\\t\\tfound = true\\n\\t\\t\\ts.Type = match\\n\\t\\t}\\n\\t\\treturn d.Skip()\\n\\t})\\n}); err != nil {\\n\\treturn errors.Wrap(err, \\"capture\\")\\n}\\n```\\n\\nIf there is a `meow` field, then the type is `Cat`, if there is a `bark` field - `Dog`, and if we didn\'t find anything, then we will get an error `unable to detect sum type variant`.\\n\\n### Detailed error messages\\n\\nogen provides detailed error messages with context, like this:\\n\\n```console\\n$ go generate\\n  - petstore-expanded.yaml:218:17 -> resolve: can\'t find value for \\"components/schemas/Do1\\"\\n          217 |       oneOf:\\n        \u2192 218 |         - $ref: \'#/components/schemas/Do1\'\\n              |                 \u2191\\n          219 |         - $ref: \'#/components/schemas/Cat\'\\n          220 |\\n          221 |     UpdatePet:\\n```\\n\\n## Summary\\n\\nMain advantages of `ogen`:\\n- Strict client and server typing\\n- Validation\\n- `oneOf` and `anyOf` support\\n- `nullable optional` support\\n- Built-in fast static router\\n- Fast JSON handling\\n- Detailed error messages"}]}')}}]);